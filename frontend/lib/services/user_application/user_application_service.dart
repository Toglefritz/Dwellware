import 'dart:async';
import 'dart:convert';
import 'dart:io';

import '../../models/application/user_application.dart';

/// A file-system–backed registry client for discovering household applications generated by the user in collaboration
/// with the Kiro agentic AI system.
///
/// This service is used to obtain a list of user application. As part of the creation of each user application, Kiro
/// will generate a "manifest" file in the directory of the application. This JSON file contains metadata and other
/// information about the user application. This service reads the per-application manifest JSON files and creates a
/// [UserApplication] model for each user application. This data is used in the frontend UI.
///
/// > Note: The service never mutates files; it is a read-only consumer.
class UserApplicationService {
  /// Creates a new service that loads [UserApplication]s from per-app manifest
  /// JSON files within a well-known `apps` directory.
  ///
  /// * [baseMetadataDirPath] — Absolute path to the **metadata** directory that contains the `apps/` subfolder. If
  ///   omitted, [defaultMetadataDirPath] is used.
  /// * [useMocks] — If `true`, [loadApplications] returns mocked data rather than reading the filesystem. Useful for
  ///   UI development.
  UserApplicationService({
    String? baseMetadataDirPath,
    bool? useMocks,
  }) : useMocks = useMocks ?? false,
       _appsDir = Directory(
         '${baseMetadataDirPath ?? defaultMetadataDirPath}/apps',
       );

  /// Whether to return mocked applications instead of reading the filesystem.
  final bool useMocks;

  /// Directory where per-app manifests (`*.json`) are stored.
  final Directory _appsDir;

  /// Returns the default metadata directory path on macOS for this project.
  ///
  /// The path is resolved as:
  /// `~/Library/Application Support/HouseholdAI/metadata`
  static String get defaultMetadataDirPath {
    final String? home = Platform.environment['HOME'];
    final String resolvedHome = home ?? '';

    return '$resolvedHome/Library/Application Support/HouseholdAI/metadata';
  }

  /// Loads all available [UserApplication]s by reading and parsing each manifest file in the `apps/` directory.
  ///
  /// In **mock mode**, this returns a stable, hard-coded set of [UserApplication]s for development.
  Future<List<UserApplication>> loadApplications() async {
    if (useMocks) {
      final List<UserApplication> mocked = _buildMockApplications();

      return mocked;
    }

    final bool exists = _appsDir.existsSync();
    if (!exists) {
      return <UserApplication>[];
    }

    final List<UserApplication> applications = <UserApplication>[];

    // Gather manifest files with a conservative read strategy.
    final List<FileSystemEntity> entries = _appsDir.listSync(followLinks: false);
    for (final FileSystemEntity entity in entries) {
      if (entity is! File) continue;
      final File file = entity;
      final String path = file.path;
      if (!path.toLowerCase().endsWith('.json')) continue;

      final UserApplication? parsed = await _readManifest(file);
      if (parsed != null) {
        applications.add(parsed);
      }
    }

    // Sort newest updated first for a pleasant dashboard experience.
    applications.sort(
      (UserApplication a, UserApplication b) => b.updatedAt.compareTo(a.updatedAt),
    );

    return applications;
  }

  /// Watches the `apps/` directory for changes and emits updated application lists. Consumers can display a
  /// live-updating grid without manual refresh.
  Stream<List<UserApplication>> watchApplications({
    Duration debounce = const Duration(milliseconds: 150),
  }) async* {
    // Initial emission
    final List<UserApplication> initial = await loadApplications();
    yield initial;

    // If using mocks, there is nothing to watch; end the stream.
    if (useMocks) return;

    final bool exists = _appsDir.existsSync();
    if (!exists) return;

    final Stream<FileSystemEvent> raw = _appsDir.watch();
    // Manual debounce to coalesce bursts of FS events.
    Timer? timer;
    final StreamController<List<UserApplication>> controller = StreamController<List<UserApplication>>.broadcast();

    final StreamSubscription<FileSystemEvent> sub = raw.listen((FileSystemEvent _) {
      timer?.cancel();
      timer = Timer(debounce, () async {
        final List<UserApplication> apps = await loadApplications();
        controller.add(apps);
      });
    });

    yield* controller.stream;

    // Cleanup when the consumer cancels the subscription.
    await controller.close();
    await sub.cancel();
    timer?.cancel();
  }

  /// Attempts to read and parse a single manifest file into a
  /// [UserApplication]. Returns `null` if the file is unreadable or invalid.
  Future<UserApplication?> _readManifest(File file) async {
    try {
      final String contents = await file.readAsString();
      final Map<String, dynamic> jsonMap = json.decode(contents) as Map<String, dynamic>;
      final UserApplication app = UserApplication.fromJson(jsonMap);
      return app;
    } on FormatException {
      // Malformed JSON or model validation: skip this manifest.
      return null;
    } on Object {
      // Any other I/O error: skip this manifest.
      return null;
    }
  }

  /// Builds a set of deterministic, typed mock applications suitable for UI development and previews. These are
  /// generated by funneling JSON through [UserApplication.fromJson] to ensure shape parity with production.
  List<UserApplication> _buildMockApplications() {
    final DateTime now = DateTime.now();

    final Map<String, dynamic> choresJson = <String, dynamic>{
      'id': 'chores-rotator',
      'title': 'Chores Rotator',
      'description': 'Custom rules for household chore rotation.',
      'status': 'running',
      'createdAt': now.subtract(const Duration(days: 12)).toIso8601String(),
      'updatedAt': now.subtract(const Duration(minutes: 8)).toIso8601String(),
      'iconUrl': null,
      'tags': <String>['household', 'automation'],
      'progress': null,
      'launchConfig': <String, dynamic>{
        'type': 'web',
        'url': 'http://localhost:18081',
        'port': 18081,
      },
    };

    final Map<String, dynamic> maintenanceJson = <String, dynamic>{
      'id': 'home-maintenance',
      'title': 'Seasonal Maintenance',
      'description': 'Plan and remind seasonal home maintenance tasks.',
      'status': 'ready',
      'createdAt': now.subtract(const Duration(days: 30)).toIso8601String(),
      'updatedAt': now.subtract(const Duration(hours: 2)).toIso8601String(),
      'iconUrl': null,
      'tags': <String>['maintenance', 'reminders'],
      'progress': <String, dynamic>{
        'percent': 100,
        'phase': 'completed',
        'lastUpdate': now.subtract(const Duration(hours: 2)).toIso8601String(),
      },
      'launchConfig': <String, dynamic>{
        'type': 'web',
        'url': 'http://localhost:18082',
        'port': 18082,
      },
    };

    final Map<String, dynamic> budgeterJson = <String, dynamic>{
      'id': 'trip-forecast',
      'title': 'Trip Cost Forecaster',
      'description': 'Estimate trip costs from bookings and local expenses.',
      'status': 'developing',
      'createdAt': now.subtract(const Duration(days: 3)).toIso8601String(),
      'updatedAt': now.subtract(const Duration(minutes: 30)).toIso8601String(),
      'iconUrl': null,
      'tags': <String>['travel', 'finance'],
      'progress': <String, dynamic>{
        'percent': 42,
        'phase': 'implementing',
        'lastUpdate': now.subtract(const Duration(minutes: 30)).toIso8601String(),
      },
      'launchConfig': <String, dynamic>{
        'type': 'web',
        'url': 'http://localhost:18083',
        'port': 18083,
      },
    };

    final List<UserApplication> apps = <UserApplication>[
      UserApplication.fromJson(choresJson),
      UserApplication.fromJson(maintenanceJson),
      UserApplication.fromJson(budgeterJson),
    ];

    return apps;
  }
}
